# 05. å®Ÿè£…ã‚¬ã‚¤ãƒ‰

## ğŸ“‹ æ¦‚è¦

ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã§ã¯ã€èªè¨¼ãƒ»èªå¯ã‚·ã‚¹ãƒ†ãƒ ã®å®Ÿè£…æ‰‹é †ã‚’æ®µéšçš„ã«èª¬æ˜ã—ã¾ã™ã€‚å®Ÿéš›ã®ã‚³ãƒ¼ãƒ‰ä¾‹ã¨ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã‚’å«ã‚ã¦ã€é–‹ç™ºè€…ãŒåŠ¹ç‡çš„ã«å®Ÿè£…ã§ãã‚‹ã‚ˆã†è¨­è¨ˆã•ã‚Œã¦ã„ã¾ã™ã€‚

## ğŸ¯ å®Ÿè£…ç›®æ¨™

### 1. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¦ä»¶
- **èªè¨¼**: JWT + APIã‚­ãƒ¼ã®ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰èªè¨¼
- **èªå¯**: ãƒ­ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡ï¼ˆRBACï¼‰
- **ä¿è­·**: ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒã‚·ãƒ¥åŒ–ã€ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãƒ­ãƒƒã‚¯
- **ç›£æŸ»**: ãƒ­ã‚°ã‚¤ãƒ³å±¥æ­´ã€ã‚¢ã‚¯ã‚»ã‚¹ãƒ­ã‚°

### 2. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¦ä»¶
- **é«˜é€Ÿ**: ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ã§ã®è»½é‡å‡¦ç†
- **åŠ¹ç‡**: å¿…è¦æ™‚ã®ã¿è©³ç´°å‡¦ç†
- **ã‚¹ã‚±ãƒ¼ãƒ©ãƒ–ãƒ«**: å¤§é‡ãƒªã‚¯ã‚¨ã‚¹ãƒˆå¯¾å¿œ

## ğŸ—ï¸ å®Ÿè£…æ‰‹é †

### Phase 1: åŸºç›¤æ§‹ç¯‰

#### 1.1 ä¾å­˜é–¢ä¿‚ã®è¨­å®š

**requirements.txt**:
```txt
fastapi==0.104.1
uvicorn==0.24.0
sqlalchemy==2.0.23
alembic==1.12.1
psycopg2-binary==2.9.9
python-jose[cryptography]==3.3.0
passlib[bcrypt]==1.7.4
python-multipart==0.0.6
pydantic[email]==2.5.0
python-dotenv==1.0.0
```

#### 1.2 ç’°å¢ƒå¤‰æ•°ã®è¨­å®š

**.env**:
```env
# ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­å®š
DATABASE_URL=postgresql://user:password@localhost:5432/historical_timeline

# JWTè¨­å®š
SECRET_KEY=your-secret-key-here
ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=30
REFRESH_TOKEN_EXPIRE_DAYS=7

# APIã‚­ãƒ¼è¨­å®š
API_KEY=your-api-key-here

# ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­å®š
PASSWORD_MIN_LENGTH=8
MAX_LOGIN_ATTEMPTS=5
LOCK_DURATION_MINUTES=30
```

#### 1.3 ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒ¢ãƒ‡ãƒ«ã®å®Ÿè£…

**app/models/user.py**:
```python
from sqlalchemy import Column, String, Boolean, DateTime
from sqlalchemy.sql import func
from app.database import Base
from app.models.enums import UserRole

class User(Base):
    __tablename__ = "users"

    id = Column(String(36), primary_key=True, index=True)
    email = Column(String(255), unique=True, index=True, nullable=False)
    username = Column(String(50), unique=True, index=True, nullable=False)
    full_name = Column(String(100))
    hashed_password = Column(String(255), nullable=False)
    is_active = Column(Boolean, default=True)
    is_superuser = Column(Boolean, default=False)
    role = Column(String(50), default=UserRole.USER)
    avatar_url = Column(String(500))
    bio = Column(String(500))
    last_login = Column(String(50))
    failed_login_attempts = Column(String(10), default="0")
    locked_until = Column(String(50))
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now())
```

#### 1.4 åˆ—æŒ™å‹ã®å®šç¾©

**app/models/enums.py**:
```python
from enum import Enum

class UserRole(str, Enum):
    USER = "user"
    MODERATOR = "moderator"
    ADMIN = "admin"
```

### Phase 2: èªè¨¼ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£

#### 2.1 JWTãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ã®å®Ÿè£…

**app/auth/utils.py**:
```python
from datetime import datetime, timedelta, timezone
from typing import Optional
from jose import JWTError, jwt
from passlib.context import CryptContext
from app.models.enums import UserRole

# ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒã‚·ãƒ¥åŒ–è¨­å®š
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# JWTè¨­å®š
SECRET_KEY = "your-secret-key-here"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30
REFRESH_TOKEN_EXPIRE_DAYS = 7

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰æ¤œè¨¼"""
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    """ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒã‚·ãƒ¥åŒ–"""
    return pwd_context.hash(password)

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    """ã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ç”Ÿæˆ"""
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

def create_refresh_token(data: dict):
    """ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ç”Ÿæˆ"""
    to_encode = data.copy()
    expire = datetime.now(timezone.utc) + timedelta(days=REFRESH_TOKEN_EXPIRE_DAYS)
    to_encode.update({"exp": expire, "type": "refresh"})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

def verify_token(token: str) -> Optional[dict]:
    """ãƒˆãƒ¼ã‚¯ãƒ³æ¤œè¨¼"""
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        return payload
    except JWTError:
        return None
```

#### 2.2 ã‚¹ã‚­ãƒ¼ãƒå®šç¾©

**app/schemas.py**:
```python
from pydantic import BaseModel, EmailStr, Field
from typing import Optional
from datetime import datetime
from app.models.enums import UserRole

# èªè¨¼ã‚¹ã‚­ãƒ¼ãƒ
class UserCreate(BaseModel):
    email: EmailStr
    username: str = Field(..., min_length=3, max_length=50)
    password: str = Field(..., min_length=8)
    full_name: Optional[str] = Field(None, max_length=100)
    is_active: bool = True
    role: UserRole = UserRole.USER

class UserLogin(BaseModel):
    username: str  # ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã¾ãŸã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼å
    password: str

class Token(BaseModel):
    access_token: str
    token_type: str
    expires_in: int
    refresh_token: Optional[str] = None

class TokenRefresh(BaseModel):
    refresh_token: str

class PasswordChange(BaseModel):
    current_password: str
    new_password: str = Field(..., min_length=8)

# ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¹ã‚­ãƒ¼ãƒ
class UserBase(BaseModel):
    email: EmailStr
    username: str
    full_name: Optional[str] = None
    is_active: bool
    role: UserRole
    avatar_url: Optional[str] = None
    bio: Optional[str] = None

class UserCreateResponse(UserBase):
    id: str
    last_login: Optional[str] = None
    failed_login_attempts: str
    locked_until: Optional[str] = None
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True

class UserUpdate(BaseModel):
    full_name: Optional[str] = Field(None, max_length=100)
    bio: Optional[str] = Field(None, max_length=500)
    avatar_url: Optional[str] = None
    role: Optional[UserRole] = None

class UserResponse(UserBase):
    id: str
    last_login: Optional[str] = None
    failed_login_attempts: str
    locked_until: Optional[str] = None
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True
```

### Phase 3: ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ“ä½œ

#### 3.1 CRUDæ“ä½œã®å®Ÿè£…

**app/crud/user.py**:
```python
from sqlalchemy.orm import Session
from sqlalchemy import and_, or_
from typing import Optional, List
from app.models.user import User
from app.schemas import UserCreate, UserUpdate
from app.auth.utils import get_password_hash, verify_password
from datetime import datetime, timezone

class UserCRUD:
    def create(self, db: Session, user_create: UserCreate) -> User:
        """ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½œæˆ"""
        hashed_password = get_password_hash(user_create.password)
        db_user = User(
            id=user_create.id,
            email=user_create.email,
            username=user_create.username,
            full_name=user_create.full_name,
            hashed_password=hashed_password,
            is_active=user_create.is_active,
            role=user_create.role
        )
        db.add(db_user)
        db.commit()
        db.refresh(db_user)
        return db_user

    def get_by_email(self, db: Session, email: str) -> Optional[User]:
        """ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã§ãƒ¦ãƒ¼ã‚¶ãƒ¼å–å¾—"""
        return db.query(User).filter(User.email == email).first()

    def get_by_username(self, db: Session, username: str) -> Optional[User]:
        """ãƒ¦ãƒ¼ã‚¶ãƒ¼åã§ãƒ¦ãƒ¼ã‚¶ãƒ¼å–å¾—"""
        return db.query(User).filter(User.username == username).first()

    def get_by_id(self, db: Session, user_id: str) -> Optional[User]:
        """IDã§ãƒ¦ãƒ¼ã‚¶ãƒ¼å–å¾—"""
        return db.query(User).filter(User.id == user_id).first()

    def authenticate(self, db: Session, username: str, password: str) -> Optional[User]:
        """èªè¨¼å‡¦ç†"""
        # ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã¾ãŸã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼åã§æ¤œç´¢
        user = db.query(User).filter(
            or_(User.email == username, User.username == username)
        ).first()
        
        if not user or not verify_password(password, user.hashed_password):
            return None
        
        return user

    def update_login_info(self, db: Session, user: User, success: bool = True):
        """ãƒ­ã‚°ã‚¤ãƒ³æƒ…å ±æ›´æ–°"""
        if success:
            user.failed_login_attempts = "0"
            user.locked_until = None
            user.last_login = datetime.now(timezone.utc).isoformat()
        else:
            attempts = int(user.failed_login_attempts) + 1
            user.failed_login_attempts = str(attempts)
            
            # 5å›å¤±æ•—ã§ãƒ­ãƒƒã‚¯
            if attempts >= 5:
                lock_until = datetime.now(timezone.utc) + timedelta(minutes=30)
                user.locked_until = lock_until.isoformat()
        
        db.commit()
        db.refresh(user)

    def get_all(self, db: Session, skip: int = 0, limit: int = 100) -> List[User]:
        """å…¨ãƒ¦ãƒ¼ã‚¶ãƒ¼å–å¾—"""
        return db.query(User).offset(skip).limit(limit).all()

    def get_active_users(self, db: Session, skip: int = 0, limit: int = 100) -> List[User]:
        """ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ¦ãƒ¼ã‚¶ãƒ¼å–å¾—"""
        return db.query(User).filter(User.is_active == True).offset(skip).limit(limit).all()

    def get_by_role(self, db: Session, role: str, skip: int = 0, limit: int = 100) -> List[User]:
        """å½¹å‰²åˆ¥ãƒ¦ãƒ¼ã‚¶ãƒ¼å–å¾—"""
        return db.query(User).filter(User.role == role).offset(skip).limit(limit).all()

    def update(self, db: Session, user: User, user_update: UserUpdate) -> User:
        """ãƒ¦ãƒ¼ã‚¶ãƒ¼æ›´æ–°"""
        update_data = user_update.dict(exclude_unset=True)
        for field, value in update_data.items():
            setattr(user, field, value)
        
        db.commit()
        db.refresh(user)
        return user

    def delete(self, db: Session, user_id: str) -> bool:
        """ãƒ¦ãƒ¼ã‚¶ãƒ¼å‰Šé™¤"""
        user = self.get_by_id(db, user_id)
        if user:
            db.delete(user)
            db.commit()
            return True
        return False

    def activate(self, db: Session, user_id: str) -> Optional[User]:
        """ãƒ¦ãƒ¼ã‚¶ãƒ¼æœ‰åŠ¹åŒ–"""
        user = self.get_by_id(db, user_id)
        if user:
            user.is_active = True
            db.commit()
            db.refresh(user)
        return user

    def deactivate(self, db: Session, user_id: str) -> Optional[User]:
        """ãƒ¦ãƒ¼ã‚¶ãƒ¼ç„¡åŠ¹åŒ–"""
        user = self.get_by_id(db, user_id)
        if user:
            user.is_active = False
            db.commit()
            db.refresh(user)
        return user

    def lock_account(self, db: Session, user_id: str, lock_minutes: int = 30) -> Optional[User]:
        """ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãƒ­ãƒƒã‚¯"""
        user = self.get_by_id(db, user_id)
        if user:
            lock_until = datetime.now(timezone.utc) + timedelta(minutes=lock_minutes)
            user.locked_until = lock_until.isoformat()
            user.failed_login_attempts = "5"
            db.commit()
            db.refresh(user)
        return user

    def unlock_account(self, db: Session, user_id: str) -> Optional[User]:
        """ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãƒ­ãƒƒã‚¯è§£é™¤"""
        user = self.get_by_id(db, user_id)
        if user:
            user.locked_until = None
            user.failed_login_attempts = "0"
            db.commit()
            db.refresh(user)
        return user

    def get_stats(self, db: Session) -> dict:
        """ãƒ¦ãƒ¼ã‚¶ãƒ¼çµ±è¨ˆå–å¾—"""
        total = db.query(User).count()
        active = db.query(User).filter(User.is_active == True).count()
        inactive = total - active
        
        return {
            "total_users": total,
            "active_users": active,
            "inactive_users": inactive
        }

    def get_role_count(self, db: Session, role: str) -> dict:
        """å½¹å‰²åˆ¥ãƒ¦ãƒ¼ã‚¶ãƒ¼æ•°å–å¾—"""
        count = db.query(User).filter(User.role == role).count()
        return {"role": role, "count": count}

user_crud = UserCRUD()
```

### Phase 4: èªè¨¼ä¾å­˜æ€§

#### 4.1 JWTèªè¨¼ä¾å­˜æ€§

**app/dependencies/jwt_auth.py**:
```python
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlalchemy.orm import Session
from app.database import get_db
from app.crud.user import user_crud
from app.auth.utils import verify_token
from app.models.enums import UserRole

security = HTTPBearer()

def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    db: Session = Depends(get_db)
):
    """ç¾åœ¨ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼å–å¾—"""
    token = credentials.credentials
    payload = verify_token(token)
    
    if payload is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    user_id = payload.get("sub")
    if user_id is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    user = user_crud.get_by_id(db, user_id)
    if user is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not found",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    if not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Inactive user"
        )
    
    return user

def get_current_active_user(current_user = Depends(get_current_user)):
    """ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ¦ãƒ¼ã‚¶ãƒ¼å–å¾—"""
    if not current_user.is_active:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Inactive user"
        )
    return current_user

def require_role(required_role: UserRole):
    """å½¹å‰²è¦æ±‚ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿"""
    def role_checker(current_user = Depends(get_current_active_user)):
        if current_user.role != required_role and current_user.role != UserRole.ADMIN:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Not enough permissions"
            )
        return current_user
    return role_checker

def require_moderator_or_admin(current_user = Depends(get_current_active_user)):
    """ãƒ¢ãƒ‡ãƒ¬ãƒ¼ã‚¿ãƒ¼ä»¥ä¸Šè¦æ±‚"""
    if current_user.role not in [UserRole.MODERATOR, UserRole.ADMIN]:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Not enough permissions"
        )
    return current_user

def require_admin(current_user = Depends(get_current_active_user)):
    """ç®¡ç†è€…è¦æ±‚"""
    if current_user.role != UserRole.ADMIN:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Not enough permissions"
        )
    return current_user
```

#### 4.2 APIã‚­ãƒ¼èªè¨¼ä¾å­˜æ€§

**app/dependencies/api_key_auth.py**:
```python
from fastapi import Depends, HTTPException, status, Header
from typing import Optional
import os

def verify_api_key(x_api_key: Optional[str] = Header(None)):
    """APIã‚­ãƒ¼èªè¨¼"""
    if x_api_key is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="API key required"
        )
    
    expected_api_key = os.getenv("API_KEY")
    if expected_api_key is None:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="API key not configured"
        )
    
    if x_api_key != expected_api_key:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid API key"
        )
    
    return x_api_key

def optional_api_key(x_api_key: Optional[str] = Header(None)):
    """ã‚ªãƒ—ã‚·ãƒ§ãƒŠãƒ«APIã‚­ãƒ¼èªè¨¼"""
    if x_api_key is None:
        return None
    
    expected_api_key = os.getenv("API_KEY")
    if expected_api_key is None:
        return None
    
    if x_api_key != expected_api_key:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid API key"
        )
    
    return x_api_key
```

### Phase 5: ãƒ«ãƒ¼ã‚¿ãƒ¼å®Ÿè£…

#### 5.1 èªè¨¼ãƒ«ãƒ¼ã‚¿ãƒ¼

**app/routers/auth.py**:
```python
from fastapi import APIRouter, Depends, HTTPException, status, Form
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.orm import Session
from app.database import get_db
from app.crud.user import user_crud
from app.auth.utils import create_access_token, create_refresh_token, verify_token
from app.schemas import UserCreate, UserCreateResponse, Token, TokenRefresh
from app.dependencies.jwt_auth import get_current_user
from datetime import timedelta, timezone
from typing import Optional

router = APIRouter(prefix="/auth", tags=["authentication"])

@router.post("/register", response_model=UserCreateResponse)
def register(user_create: UserCreate, db: Session = Depends(get_db)):
    """ãƒ¦ãƒ¼ã‚¶ãƒ¼ç™»éŒ²"""
    # ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹é‡è¤‡ãƒã‚§ãƒƒã‚¯
    if user_crud.get_by_email(db, user_create.email):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email already registered"
        )
    
    # ãƒ¦ãƒ¼ã‚¶ãƒ¼åé‡è¤‡ãƒã‚§ãƒƒã‚¯
    if user_crud.get_by_username(db, user_create.username):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Username already taken"
        )
    
    # ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½œæˆ
    user = user_crud.create(db, user_create)
    return user

@router.post("/login", response_model=Token)
def login(
    form_data: OAuth2PasswordRequestForm = Depends(),
    db: Session = Depends(get_db)
):
    """ãƒ­ã‚°ã‚¤ãƒ³"""
    # ãƒ¦ãƒ¼ã‚¶ãƒ¼èªè¨¼
    user = user_crud.authenticate(db, form_data.username, form_data.password)
    
    if not user:
        # èªè¨¼å¤±æ•—æ™‚ã®å‡¦ç†
        user_by_username = user_crud.get_by_username(db, form_data.username)
        if user_by_username:
            user_crud.update_login_info(db, user_by_username, success=False)
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    # ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãƒ­ãƒƒã‚¯ãƒã‚§ãƒƒã‚¯
    if user.locked_until:
        lock_time = datetime.fromisoformat(user.locked_until.replace('Z', '+00:00'))
        if datetime.now(timezone.utc) < lock_time:
            raise HTTPException(
                status_code=status.HTTP_423_LOCKED,
                detail="Account is locked"
            )
    
    # ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒã‚§ãƒƒã‚¯
    if not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Inactive user"
        )
    
    # ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸæ™‚ã®å‡¦ç†
    user_crud.update_login_info(db, user, success=True)
    
    # ãƒˆãƒ¼ã‚¯ãƒ³ç”Ÿæˆ
    access_token_expires = timedelta(minutes=30)
    access_token = create_access_token(
        data={"sub": user.id, "email": user.email, "role": user.role},
        expires_delta=access_token_expires
    )
    
    refresh_token = create_refresh_token(
        data={"sub": user.id, "email": user.email, "role": user.role}
    )
    
    return {
        "access_token": access_token,
        "token_type": "bearer",
        "expires_in": 1800,
        "refresh_token": refresh_token
    }

@router.post("/refresh", response_model=Token)
def refresh_token(token_data: TokenRefresh):
    """ãƒˆãƒ¼ã‚¯ãƒ³æ›´æ–°"""
    payload = verify_token(token_data.refresh_token)
    
    if payload is None or payload.get("type") != "refresh":
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid refresh token"
        )
    
    # æ–°ã—ã„ã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ç”Ÿæˆ
    access_token_expires = timedelta(minutes=30)
    access_token = create_access_token(
        data={"sub": payload["sub"], "email": payload["email"], "role": payload["role"]},
        expires_delta=access_token_expires
    )
    
    return {
        "access_token": access_token,
        "token_type": "bearer",
        "expires_in": 1800
    }

@router.get("/me", response_model=UserCreateResponse)
def get_current_user_info(current_user = Depends(get_current_user)):
    """ç¾åœ¨ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±å–å¾—"""
    return current_user

@router.put("/me", response_model=UserCreateResponse)
def update_current_user(
    user_update: UserUpdate,
    current_user = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """ç¾åœ¨ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±æ›´æ–°"""
    updated_user = user_crud.update(db, current_user, user_update)
    return updated_user

@router.post("/change-password")
def change_password(
    current_password: str = Form(...),
    new_password: str = Form(...),
    current_user = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å¤‰æ›´"""
    # ç¾åœ¨ã®ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰æ¤œè¨¼
    if not verify_password(current_password, current_user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Incorrect current password"
        )
    
    # æ–°ã—ã„ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒã‚·ãƒ¥åŒ–
    hashed_new_password = get_password_hash(new_password)
    current_user.hashed_password = hashed_new_password
    db.commit()
    
    return {"message": "Password changed successfully"}

@router.post("/logout")
def logout(current_user = Depends(get_current_user)):
    """ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ"""
    # å®Ÿéš›ã®å®Ÿè£…ã§ã¯ã€ãƒˆãƒ¼ã‚¯ãƒ³ã®ãƒ–ãƒ©ãƒƒã‚¯ãƒªã‚¹ãƒˆåŒ–ãªã©ã‚’æ¤œè¨
    return {"message": "Logged out successfully"}
```

#### 5.2 ãƒ¦ãƒ¼ã‚¶ãƒ¼ç®¡ç†ãƒ«ãƒ¼ã‚¿ãƒ¼

**app/routers/users.py**:
```python
from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.orm import Session
from typing import List
from app.database import get_db
from app.crud.user import user_crud
from app.schemas import UserCreateResponse, UserUpdate
from app.dependencies.jwt_auth import (
    get_current_user, require_moderator_or_admin, require_admin
)

router = APIRouter(prefix="/users", tags=["users"])

@router.get("/", response_model=List[UserCreateResponse])
def get_users(
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=1, le=1000),
    current_user = Depends(require_admin),
    db: Session = Depends(get_db)
):
    """ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸€è¦§å–å¾—ï¼ˆç®¡ç†è€…ã®ã¿ï¼‰"""
    users = user_crud.get_all(db, skip=skip, limit=limit)
    return users

@router.get("/active", response_model=List[UserCreateResponse])
def get_active_users(
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=1, le=1000),
    current_user = Depends(require_moderator_or_admin),
    db: Session = Depends(get_db)
):
    """ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸€è¦§å–å¾—ï¼ˆãƒ¢ãƒ‡ãƒ¬ãƒ¼ã‚¿ãƒ¼ä»¥ä¸Šï¼‰"""
    users = user_crud.get_active_users(db, skip=skip, limit=limit)
    return users

@router.get("/role/{role}", response_model=List[UserCreateResponse])
def get_users_by_role(
    role: str,
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=1, le=1000),
    current_user = Depends(require_moderator_or_admin),
    db: Session = Depends(get_db)
):
    """å½¹å‰²åˆ¥ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸€è¦§å–å¾—ï¼ˆãƒ¢ãƒ‡ãƒ¬ãƒ¼ã‚¿ãƒ¼ä»¥ä¸Šï¼‰"""
    users = user_crud.get_by_role(db, role=role, skip=skip, limit=limit)
    return users

@router.get("/{user_id}", response_model=UserCreateResponse)
def get_user(
    user_id: str,
    current_user = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """ãƒ¦ãƒ¼ã‚¶ãƒ¼è©³ç´°å–å¾—ï¼ˆè‡ªåˆ†è‡ªèº«ã¾ãŸã¯ç®¡ç†è€…ã®ã¿ï¼‰"""
    # æ¨©é™ãƒã‚§ãƒƒã‚¯
    if current_user.id != user_id and current_user.role != "admin":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Not enough permissions"
        )
    
    user = user_crud.get_by_id(db, user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    
    return user

@router.put("/{user_id}", response_model=UserCreateResponse)
def update_user(
    user_id: str,
    user_update: UserUpdate,
    current_user = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """ãƒ¦ãƒ¼ã‚¶ãƒ¼æ›´æ–°ï¼ˆè‡ªåˆ†è‡ªèº«ã¾ãŸã¯ç®¡ç†è€…ã®ã¿ï¼‰"""
    # æ¨©é™ãƒã‚§ãƒƒã‚¯
    if current_user.id != user_id and current_user.role != "admin":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Not enough permissions"
        )
    
    user = user_crud.get_by_id(db, user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    
    updated_user = user_crud.update(db, user, user_update)
    return updated_user

@router.delete("/{user_id}")
def delete_user(
    user_id: str,
    current_user = Depends(require_admin),
    db: Session = Depends(get_db)
):
    """ãƒ¦ãƒ¼ã‚¶ãƒ¼å‰Šé™¤ï¼ˆç®¡ç†è€…ã®ã¿ï¼‰"""
    success = user_crud.delete(db, user_id)
    if not success:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    
    return {"message": "User deleted successfully"}

@router.post("/{user_id}/activate", response_model=UserCreateResponse)
def activate_user(
    user_id: str,
    current_user = Depends(require_admin),
    db: Session = Depends(get_db)
):
    """ãƒ¦ãƒ¼ã‚¶ãƒ¼æœ‰åŠ¹åŒ–ï¼ˆç®¡ç†è€…ã®ã¿ï¼‰"""
    user = user_crud.activate(db, user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    
    return user

@router.post("/{user_id}/deactivate", response_model=UserCreateResponse)
def deactivate_user(
    user_id: str,
    current_user = Depends(require_admin),
    db: Session = Depends(get_db)
):
    """ãƒ¦ãƒ¼ã‚¶ãƒ¼ç„¡åŠ¹åŒ–ï¼ˆç®¡ç†è€…ã®ã¿ï¼‰"""
    user = user_crud.deactivate(db, user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    
    return user

@router.post("/{user_id}/lock", response_model=UserCreateResponse)
def lock_user(
    user_id: str,
    lock_minutes: int = Query(30, ge=1, le=1440),
    current_user = Depends(require_admin),
    db: Session = Depends(get_db)
):
    """ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãƒ­ãƒƒã‚¯ï¼ˆç®¡ç†è€…ã®ã¿ï¼‰"""
    user = user_crud.lock_account(db, user_id, lock_minutes)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    
    return user

@router.post("/{user_id}/unlock", response_model=UserCreateResponse)
def unlock_user(
    user_id: str,
    current_user = Depends(require_admin),
    db: Session = Depends(get_db)
):
    """ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãƒ­ãƒƒã‚¯è§£é™¤ï¼ˆç®¡ç†è€…ã®ã¿ï¼‰"""
    user = user_crud.unlock_account(db, user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    
    return user

@router.get("/stats/count")
def get_user_stats(
    current_user = Depends(require_moderator_or_admin),
    db: Session = Depends(get_db)
):
    """ãƒ¦ãƒ¼ã‚¶ãƒ¼çµ±è¨ˆå–å¾—ï¼ˆãƒ¢ãƒ‡ãƒ¬ãƒ¼ã‚¿ãƒ¼ä»¥ä¸Šï¼‰"""
    return user_crud.get_stats(db)

@router.get("/stats/role/{role}/count")
def get_role_count(
    role: str,
    current_user = Depends(require_moderator_or_admin),
    db: Session = Depends(get_db)
):
    """å½¹å‰²åˆ¥ãƒ¦ãƒ¼ã‚¶ãƒ¼æ•°å–å¾—ï¼ˆãƒ¢ãƒ‡ãƒ¬ãƒ¼ã‚¿ãƒ¼ä»¥ä¸Šï¼‰"""
    return user_crud.get_role_count(db, role)
```

### Phase 6: ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³çµ±åˆ

#### 6.1 ãƒ¡ã‚¤ãƒ³ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³

**app/main.py**:
```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from app.routers import auth, users
from app.database import engine
from app.models import user

# ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒ†ãƒ¼ãƒ–ãƒ«ä½œæˆ
user.Base.metadata.create_all(bind=engine)

app = FastAPI(
    title="Historical Timeline API",
    description="èªè¨¼ãƒ»èªå¯æ©Ÿèƒ½ä»˜ãæ­´å²çš„å¹´è¡¨API",
    version="1.0.0"
)

# CORSè¨­å®š
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ãƒ«ãƒ¼ã‚¿ãƒ¼ç™»éŒ²
app.include_router(auth.router)
app.include_router(users.router)

@app.get("/")
def read_root():
    return {"message": "Historical Timeline API"}

@app.get("/health")
def health_check():
    return {"status": "healthy"}
```

## ğŸ§ª ãƒ†ã‚¹ãƒˆå®Ÿè£…

### 1. èªè¨¼ãƒ†ã‚¹ãƒˆ

**tests/routers/test_auth.py**:
```python
import pytest
from fastapi.testclient import TestClient
from sqlalchemy.orm import Session
from app.main import app
from app.crud.user import user_crud
from app.schemas import UserCreate

client = TestClient(app)

@pytest.fixture
def test_user_data():
    return {
        "email": "test@example.com",
        "username": "testuser",
        "password": "testpassword123",
        "full_name": "Test User",
        "is_active": True,
        "role": "user"
    }

def test_register_user(test_user_data):
    """ãƒ¦ãƒ¼ã‚¶ãƒ¼ç™»éŒ²ãƒ†ã‚¹ãƒˆ"""
    response = client.post("/auth/register", json=test_user_data)
    assert response.status_code == 201
    data = response.json()
    assert data["email"] == test_user_data["email"]
    assert data["username"] == test_user_data["username"]
    assert "password" not in data

def test_login_success(test_user_data):
    """ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸãƒ†ã‚¹ãƒˆ"""
    # ãƒ¦ãƒ¼ã‚¶ãƒ¼ç™»éŒ²
    client.post("/auth/register", json=test_user_data)
    
    # ãƒ­ã‚°ã‚¤ãƒ³
    response = client.post("/auth/login", data={
        "username": test_user_data["email"],
        "password": test_user_data["password"]
    })
    assert response.status_code == 200
    data = response.json()
    assert "access_token" in data
    assert "refresh_token" in data

def test_login_failure(test_user_data):
    """ãƒ­ã‚°ã‚¤ãƒ³å¤±æ•—ãƒ†ã‚¹ãƒˆ"""
    # ãƒ¦ãƒ¼ã‚¶ãƒ¼ç™»éŒ²
    client.post("/auth/register", json=test_user_data)
    
    # é–“é•ã£ãŸãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã§ãƒ­ã‚°ã‚¤ãƒ³
    response = client.post("/auth/login", data={
        "username": test_user_data["email"],
        "password": "wrongpassword"
    })
    assert response.status_code == 401
```

### 2. ãƒ¦ãƒ¼ã‚¶ãƒ¼ç®¡ç†ãƒ†ã‚¹ãƒˆ

**tests/routers/test_users.py**:
```python
import pytest
from fastapi.testclient import TestClient
from app.main import app

client = TestClient(app)

@pytest.fixture
def admin_token():
    """ç®¡ç†è€…ãƒˆãƒ¼ã‚¯ãƒ³å–å¾—"""
    # ç®¡ç†è€…ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½œæˆ
    admin_data = {
        "email": "admin@example.com",
        "username": "admin",
        "password": "adminpassword123",
        "full_name": "Admin User",
        "role": "admin"
    }
    client.post("/auth/register", json=admin_data)
    
    # ãƒ­ã‚°ã‚¤ãƒ³
    response = client.post("/auth/login", data={
        "username": admin_data["email"],
        "password": admin_data["password"]
    })
    return response.json()["access_token"]

def test_get_users(admin_token):
    """ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸€è¦§å–å¾—ãƒ†ã‚¹ãƒˆ"""
    headers = {"Authorization": f"Bearer {admin_token}"}
    response = client.get("/users/", headers=headers)
    assert response.status_code == 200
    assert isinstance(response.json(), list)

def test_get_user_by_id(admin_token):
    """ãƒ¦ãƒ¼ã‚¶ãƒ¼è©³ç´°å–å¾—ãƒ†ã‚¹ãƒˆ"""
    # ãƒ†ã‚¹ãƒˆãƒ¦ãƒ¼ã‚¶ãƒ¼ä½œæˆ
    user_data = {
        "email": "user@example.com",
        "username": "user",
        "password": "userpassword123",
        "full_name": "Test User",
        "role": "user"
    }
    user_response = client.post("/auth/register", json=user_data)
    user_id = user_response.json()["id"]
    
    headers = {"Authorization": f"Bearer {admin_token}"}
    response = client.get(f"/users/{user_id}", headers=headers)
    assert response.status_code == 200
    data = response.json()
    assert data["id"] == user_id
```

## ğŸ”§ è¨­å®šãƒ»ãƒ‡ãƒ—ãƒ­ã‚¤

### 1. ç’°å¢ƒè¨­å®š

**config/settings.py**:
```python
from pydantic_settings import BaseSettings
from typing import Optional

class Settings(BaseSettings):
    # ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­å®š
    database_url: str = "postgresql://user:password@localhost:5432/historical_timeline"
    
    # JWTè¨­å®š
    secret_key: str = "your-secret-key-here"
    algorithm: str = "HS256"
    access_token_expire_minutes: int = 30
    refresh_token_expire_days: int = 7
    
    # APIã‚­ãƒ¼è¨­å®š
    api_key: Optional[str] = None
    
    # ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­å®š
    password_min_length: int = 8
    max_login_attempts: int = 5
    lock_duration_minutes: int = 30
    
    class Config:
        env_file = ".env"

settings = Settings()
```

### 2. Dockerè¨­å®š

**Dockerfile**:
```dockerfile
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

**docker-compose.yml**:
```yaml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://user:password@db:5432/historical_timeline
      - SECRET_KEY=your-secret-key-here
      - API_KEY=your-api-key-here
    depends_on:
      - db

  db:
    image: postgres:15
    environment:
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=historical_timeline
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:
```

## ğŸ“Š ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–

### 1. ã‚­ãƒ£ãƒƒã‚·ãƒ¥æˆ¦ç•¥

```python
import redis
from functools import lru_cache

# Redisã‚­ãƒ£ãƒƒã‚·ãƒ¥
redis_client = redis.Redis(host='localhost', port=6379, db=0)

def cache_user_info(user_id: str, user_data: dict, ttl: int = 3600):
    """ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚­ãƒ£ãƒƒã‚·ãƒ¥"""
    redis_client.setex(f"user:{user_id}", ttl, json.dumps(user_data))

def get_cached_user(user_id: str) -> Optional[dict]:
    """ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã•ã‚ŒãŸãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±å–å¾—"""
    cached = redis_client.get(f"user:{user_id}")
    return json.loads(cached) if cached else None

# ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚­ãƒ£ãƒƒã‚·ãƒ¥
@lru_cache(maxsize=1000)
def get_role_permissions(role: str) -> List[str]:
    """ãƒ­ãƒ¼ãƒ«æ¨©é™ã‚­ãƒ£ãƒƒã‚·ãƒ¥"""
    return role_permissions.get(role, [])
```

### 2. éåŒæœŸå‡¦ç†

```python
import asyncio
from concurrent.futures import ThreadPoolExecutor

executor = ThreadPoolExecutor(max_workers=4)

async def async_password_verification(plain_password: str, hashed_password: str) -> bool:
    """éåŒæœŸãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰æ¤œè¨¼"""
    loop = asyncio.get_event_loop()
    return await loop.run_in_executor(
        executor, 
        verify_password, 
        plain_password, 
        hashed_password
    )
```

## ğŸ”— é–¢é€£ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

- [01. èªè¨¼ã‚·ã‚¹ãƒ†ãƒ æ¦‚è¦](./01-èªè¨¼ã‚·ã‚¹ãƒ†ãƒ æ¦‚è¦.md)
- [02. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­è¨ˆ](./02-ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­è¨ˆ.md)
- [03. APIä»•æ§˜æ›¸](./03-APIä»•æ§˜æ›¸.md)
- [04. ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å›³](./04-ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å›³.md) 